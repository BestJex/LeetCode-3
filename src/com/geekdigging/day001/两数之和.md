## 题目：两数之和

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

示例:

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```

## 思路

这道题如果是做加法，有点不是那么好搞，思路稍微转变下，不做加法做减法，使用目标值减去数组中的值，判断结果是否也在数组中即可。


## 方案一：暴力破解

两个循环套一起，直接暴力迭代，这种方案，除了时间复杂度有点高，其他没啥不好的。

```java
public int[] twoSum_1(int[] nums, int target) {
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < nums.length; j++) {
            if (nums[j] == target - nums[i]) {
                return new int[]{i, j};
            }
        }
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

因为总共有 n 个元素，而对于其中的每个元素来讲，我们都需要遍历整个数组来寻找是否存在它所需要的对应的元素，这将耗费 O(n) 的时间。

因此，整个算法：

时间复杂度： O(n^2) 。

空间复杂度： O(1) 。

## 两次 hash

这个方案的解题思路是找到除了循环以外，更有效率的方式检测数据列表中是否含有某个数据。



```java
public int[] twoSum_2(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        map.put(nums[i], i);
    }
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement) && map.get(complement) != i) {
            return new int[] {i, map.get(complement)};
        }
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

说实话，看到官方提供的这个解题方案，我有点蒙蔽，为啥要循环两次，明明一次就能搞定的事情。

实际上在第一次循环把数据放到 map 中的时候，直接进行运算判断，来找到我们需要的数据。下面的一次 hash 的解决方案就是实现了这个思路。



## 一次 hash

```java
public int[] twoSum_3(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
```